---
title: "From Excel to R"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(knitr)
library(dplyr)
#remotes::install_github("rstudio/gradethis")
gradethis::gradethis_setup()
```

# Introduction to R data types, variables and functions

## Intro and Setup

In this tutorial we'll introduce some very basic data types in R and show how you can use them to construct something very similar to an Excel spreadsheet that you can then use to analyse using code. 

This document is interactive. You will see coding boxes like the one below where you can type and run code to try things for yourself.

```{r demo, exercise=TRUE}
"Hello World!"
```
```{r demo-check}
grade_result(
  pass_if(~identical(.result, "Hello World!"))
)
```

- To run code, click the `Run Code` button. You will see any output appear below the box
- In some cases, there is a `Submit Answer` button that will provide feedback
- If you make mistakes you will see errors appear, but don't worry, there is a `Start Over` button in case you need it.

## Data Types

There are many different types of data we put into spreadsheets, but in most cases we can break them down into a few simple categories of values. Three of the most common types of data entered into a spreadsheet are _numbers_, _text_ and _boolean_ values.

### Numbers

In most programming languages like R, you can work with numbers the same way as you would in a calculator.
For example:
```{r ex1, exercise=TRUE, exercise.eval=TRUE}
1 + 1
```

_Try any of the other basic arithmetic operations using `-`, `*` or `/` and try using decimal numbers as well like `2.5`_

_--- SIDE NOTE ---_

_In programming things are always very explicit, and whole numbers (integers), decimal numbers, complex numbers etc. are technically all considered different data types, though for this intro we won't worry about that._


### Text

The other common type of values are text (often called _strings_ when programming). 
You can write strings by wrapping your text in quotes like this:
```{r ex2, exercise=TRUE, exercise.eval=TRUE}
"This is a string of text"
```
 _Try changing the text_
 
### Boolean

A Boolean value is a binary value that simply means _true_ or _false_. In R these can be written as `TRUE` / `FALSE` or `T` / `F`
```{r ex3, exercise=TRUE, exercise.eval=TRUE}
TRUE
```
_Note that this is case sensitve and you must use all capital letters_
 
### Vectors
 
We can group multiple values of the _same type_ by wrapping them in a vector `c()`

```{r ex4, exercise=TRUE}
c(1,2,3,4,5)
```
_Replace the vector with one containing 3 strings: cat, dog, horse_ 

_You can check your answer once finished_
```{r ex4-check}
grade_result(
  pass_if(~identical(.result, c("cat", "dog", "horse")))
)
```

### Lists
 
We can group multiple values of the _different types_ by creating a list `list()`

```{r ex5, exercise=TRUE}
list(1, "test", FALSE)
```


Lists allow you to give a unique name to each of its entries like so:

```{r ex6, exercise=TRUE}
list(val1 = 1, val2 = "test", val3 = FALSE)
```

### Putting it all together

Create the following list:

- The first entry contains a vector of the numbers 1 - 3 and is named _first_
- The second entry contains the first 3 letters of the alphabet and is named _second_

```{r ex7, exercise=TRUE}
list()
```

```{r ex7-check}
grade_result(
  pass_if(~identical(.result, list(first = c(1,2,3), 
                                   second = c("a", "b", "c"))
))
)
```

## Data Frames

### Building on what we know ...

Now you learned basic data types, we can use them to recreate a spreadsheet.
Let's take a look at this simple spreadsheet table below

```{r echo=FALSE}
data.frame(name = c("Mohamet", "Lin Yi", "Nina"), age = c(21,19,24),
           student = c(TRUE, TRUE, FALSE)) %>% kable()
```

This simple, basic spreadsheet records student info and is a table with the following properties:

- Each row is an entry in the table
- Each column records a different observation
- Every column has a header

Note that the values in every column are of the same data type. This means we can represent them as a vector. For example, the first column would be `c("Mohamet", "Lin Yi", "Nina")`. If we do this for all three columns and store them as a list, we can recreate the whole table like this:

```{r}
list(
  name = c("Mohamet", "Lin Yi", "Nina"), 
  age = c(42,33,19),
  student = c(TRUE, TRUE, FALSE)
) 
```

We just converted our spreadsheet to a combination of data types in R! Note that the way we write it in R looks like the table was rotated with the columns now horizontal an the rows vertical.

### Introducing the data frame

Although the list above is valid representation of a table, R has another, special, built-in datatype that optimises working with this type of data called a _data frame_. It is constructed very much like we did with the list but is treated and rendered differently:
```{r}
data.frame(
  name = c("Mohamet", "Lin Yi", "Nina"), 
  age = c(42,33,19),
  student = c(TRUE, TRUE, FALSE)
) 
```

A data frame imposes more restrictions on how the data can be organised as it has to conform to the rules of a well-organised spreadsheet table. These rules are:

- Every column needs a unique name
- Every column needs to be a vector (i.e. contains a single data type)
- The length of each column has to be the same

_There are more rules that you should follow to create a tidy table, but they will be discussed in another section_

### Try it yourself

Edit the following code so it becomes a _valid_ data frame with 3 rows, and the columns: animal, legs and mammal

```{r ex8, exercise=TRUE}
data.frame(
  animal = c("dog", "beetle", "spider"), 
  mammal = c(TRUE),
  c(4, 6, 8)
) 
```

```{r ex8-check}
grade_result(
  pass_if(~identical(.result, data.frame(
    animal = c("dog", "beetle", "spider"), 
    mammal = c(TRUE, FALSE, FALSE),
    legs = c(4, 6, 8)
    ) 
))
)
```

## Variables

Now we know how to create different types of data in R, let's see how we can store and access them in R.

### Storing data into a variable

We define (assign) a variable by picking a name followed by the assignment `<-` operator and then the value (or calculation that will generate one).

Valid variable names:

- Must start with a letter
- can only have alphanumeric characters (A-Z, a-z, 0-9) or `_` or `.`

```{r ex9, exercise=TRUE, exercise.eval=TRUE}
x <- FALSE
y2 <- data.frame(x = c(1,2,3), y = c("A", "B", "C"))
other_var <- (6 + 4) / 2

x
```

_Note that running a line containing a variable that has been assigned will print its value. Try and replace x with any of the other variables to see its value_

### Updating a variable

You can update a variable by using the same name, but assigning a different value
```{r ex10, exercise=TRUE}
x <- 1
x
x <- 2 + 3
x
```

We can also use the values stored in variables to perform calculations
```{r ex11, exercise=TRUE}
x <- 5
y <- x * 2
y
```

We can even update a variable by using it's own value then reassigning it
```{r ex12, exercise=TRUE}
x <- 10 - 4
x <- x / 2
x
```

#### Try it yourself
Create a variable `prod` that stores the product of x, y and z and then display the result

```{r ex13, exercise=TRUE, exercise.reveal_solution = FALSE}
x <- 5
y <- 7
z <- 11

```


```{r ex13-solution}
x <- 5
y <- 7
z <- 11
prod <- x * y * z
prod
```

```{r ex13-check}
grade_this_code()
```

## Functions

### Intro

The power of programming lies in the ability to execute a set of instructions automatically and being able to reuse code written by others or yourself. This a accomplished using _functions_. Just as in mathematics, a function contains a set of instructions, with variables or parameters that serve as placeholders. 

Let say we have a vector x  ...
```r
x = c(1, 15, 22, 10)
```
... and we want to calculate the mean value. R has a built-in function called `mean` which takes in a vector and returns the mean:
```r
mean(x)
```
```{r ex14, exercise=TRUE}
values <- c(1, 15, 22, 10)
result = mean(values)
result
```

_Try to replace the mean function with some other basic functions you can execute on vectors of numbers like `min` or `max` or `sum`_

### Arguments

Some functions have multiple parameters or arguments that you have to specify. For example, if we want to round off a number to 3 decimal points ...
```{r}
value <- 17/13
value
round(x = value, digits = 3)
```
... we set `x` to the value and `digits` to 3.

To know which arguments a function takes, you have several options

#### Option 1: look at the function code

Run the function _without_ the  brackets `()` to print its code and look at the arguments listed at the top
```{r}
round
```

_Note that the second argument here already has a default value assigned (see notes below for more details)_

#### Option 2: load the function documentation

Run the function _without_ the  brackets and put a question mark in front of it. This will open up the documentation (might not work in this online tutorial) 
```{r ex15, exercise=TRUE}
?round
```
_Note that the documentation has much more details on how to use the function and what each argument means_

#### Option 3: Code editor tooltips

Many code editors like [R Studio](https://posit.co/download/rstudio-desktop/) or [VS Code](https://code.visualstudio.com/) will automatically show function arguments whilst writing code or when you hover over a function name in your code. Even here you will see suggestions pop-up when you start typing the brackets of a known function

```{r ex16, exercise=TRUE}
round

```

#### Notes about function arguments

If you don't specify the argument names explicitly, the first value will become the first listed argument, the second the next, etc.
```{r}
round(1.333, 1)
```
_This implicit argument assignment will be translated to round(x = 1.333, digits = 1) when the code is run_

Functions can come with default values for some of its arguments, which you don't have to set if you are OK with the value. In other words, functions have required arguments (i.e. no default and you have to provide a value) and optional arguments (you can choose to override the default if you want). Look at the function documentation to see which ones are required.
```{r}
round(1.333)
```
_By default `digits = 0`_

You can combine implicit (unnamed) and explicit (named) arguments, but the implicit ones always have to come first and all required arguments need to have a value.
```{r}
format(15658475, big.mark = ",")
```
_In this example, big.mark is the 9th argument, but since all apart from the first argument have default values, we can use named arguments to only override those we need to change_

### Try it yourself

Create a new variable called _vec_sorted_ where all the numbers in _vec_ are in _decreasing_ order (i.e. highest to lowest) and then display the result. 

_Tip: The function you want to use is called `sort`_

```{r ex17, exercise=TRUE, exercise.reveal_solution = FALSE}
vec <- c(11.2, 16, 0.6, 8.89)

```


```{r ex17-solution}
vec <- c(11.2, 16, 0.6, 8.89)
vec_sorted <- sort(x = vec, decreasing = TRUE)
vec_sorted
```

```{r ex17-check}
grade_this_code()
```

### Combining functions

Functions can use other functions as input to create more complex behaviour. There are two ways of going this: 

#### Nested functions

Just as in mathematics, the inner most calculations of nested functions are performed before the outer ones can use their results.

```{r}
floor(sqrt(2))
```
_The square root function is run first before the value is used in the flooring function_

#### Piping (chaining) functions

Highly nested functions can become difficult to read, so it it also possible to write your code differently by using the result from one function as the input for the next one using the piping operator `|>` (`|` followed by `>`).

```{r}
sqrt(2) |> floor()
```

* The function that needs to be executed first comes first in the chain
* The result from the previous function will occupy the _first_ argument slot of the next function. 
* You can add and optional named arguments to a function later in the chain

More complex example using calculating and exponential function result:
```{r}
sqrt(2) |> exp() |> round(digits = 3) 
```
_Take the square root of 2, raise e (Euler's number) to this value and then round the result to 3 digits_

_This is more readable than `round(exp(sqrt(2)),digits = 3)`_

__ NOTE ON THE PIPING OPERATOR __

The built-in piping operator `<|` was only introduced in R 4.1.0 in 2021. It was already possible long before that to use piping but this required an additional package to be installed. Hence, you will still see a lot of code using an alternative pipe which looks like `%>%`. Both are identical in functionality.

### Try it yourself

- On line 2, write a _nested_ set of functions what will `sum` _vec_ and then `floor` the result (i.e. round down to the nearest integer) 
- On line 3, write the same set of functions but now using piping


```{r ex18, exercise=TRUE, exercise.reveal_solution = FALSE}
vec <- c(65.001,58,412.4,36,87.6666,4,11,0.69)
```


```{r ex18-solution}
vec <- c(65.001,58,412.4,36,87.6666,4,11,0.69)
floor(sum(vec))
sum(vec) |> floor()
```

```{r ex18-check}
grade_this_code()
```

## Vector operations

Remember that a data frame in essence is a list of column vectors. Before we learn to work with this, it's important to know how R makes it very easy to perform operations across vectors. We'll just explore the basics you need here.

### Simple vector math

When you perform basic arithmetic operations, on a vector, they will be carried out for every element in that vector and return a new vector with all results

```{r ex19, exercise=TRUE, exercise.eval=TRUE}
vec <- c(2,4,6,8,10)
vec / 2
```
_You can try out other basic operations like `+`, `-` or `*`_

### Operations with multiple vecors

When you perform basic arithmetic operations using two vectors they will be carried out by using the first element of each vector for the first calculation, the the second for the next one and so on, returning again a vector with all results.

```{r ex20, exercise=TRUE, exercise.eval=TRUE}
vec <- c(1,2,3,4,5)
vec + vec
```
_You can try out other basic operations like `+`, `-` or `*`_

### Functions across vectors

Finally, you can use functions across a vector. The result depends on what the effect of the function is. For example:

```{r}
vec <- c(1.554,6.23,2.201,0.01366)
sum(vec)
```
_As seen before, this will sum all elements in the vector and return a single value_

```{r}
vec <- c(1.554,6.23,2.201,0.1366)
round(vec, digits = 1)
```
_On the other hand, if a function is made to be run on a single value, it will just be repeated for every value in the vector and return the result vector_

### Try it yourself

If you want to normalize a list (vector) of values so they all fall between 0 and 1, you first subtract the `mean` from every value, then divide each result by the difference between the `max` and `min` value of the list

```{r ex21, exercise=TRUE, exercise.reveal_solution = FALSE}
vec <- c(11,6,3,8,9)

```
_The result after normalisation should be: 1.000, 0.375, 0.000, 0.625, 0.750_

```{r ex21-solution}
vec <- c(11,6,3,8,9)
(vec - min(vec)) / (max(vec) - min(vec))
```

```{r ex21-check}
grade_this_code()
```

## Wrap-up

Congratulations, you now know all the basics to be ready to start working with data frames in R! You can revisit this introduction at any time, but don't worry if some things are still unclear, learning to code takes time and frustration is definitely part of the experience, but you'll have more opportunity to practice soon! 